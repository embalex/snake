{"version":3,"sources":["gameLogic/useKeys/types.ts","gameLogic/snake/types.ts","webpack:///./src/constants.ts?85ee","sceneHelper/utils.ts","sceneHelper/index.tsx","sceneHelper/Component.tsx","utils.ts","gameLogic/utils.ts","gameLogic/apple/utils.ts","gameLogic/apple/index.ts","gameLogic/game/index.ts","gameLogic/snake/utils.ts","gameLogic/snake/index.ts","gameLogic/stepper/index.ts","gameLogic/stepper/constants.ts","gameLogic/useKeys/utils.ts","gameLogic/useKeys/index.ts","gameLogic/useGameLogic.ts","Info.tsx","camera/Camera.tsx","model/utils.ts","model/useModel.ts","model/index.ts","model/Apple.tsx","model/BigTree.tsx","model/Bush.tsx","model/Ducky.tsx","model/Magmacube.tsx","model/PalmTree.tsx","Ground/utils.ts","Ground/index.tsx","Snake.tsx","Scene.tsx","App.tsx","index.tsx"],"names":["KeyPressedEnum","DirectionKeyPressedEnum","MoveDirectionEnum","FIELD_SIZE","HALF_FIELD_SIZE","PLANET_SIZE","BLOCKED_ZONE_SIZE","DUCK_START_POSITION","x","y","angle","UPDATES_SETTINGS","NAME","index","getObject3DByName","scene","name","object3D","children","find","value","undefined","Error","getObject3DPositionByName","position","rotation","z","setObject3DPositionByName","isUnderground","setX","setY","setZ","set","isSceneReady","error","SceneHelperComponent","forwardRef","props","ref","useThree","current","sceneHelperUtil","utils","degToRad","deg","Math","PI","toGlobal","setPosition","isUnderGround","getPosition","globalPosition","isPositionInBlocked","blockedPositions","testX","testY","filter","blockedX","blockedY","length","calcRandomPositions","getRandomCoordinates","floor","random","appleBuilder","sceneRef","applePosition","reset","step","snakePosition","isSnakeEatApple","snake","apple","x1","y1","x2","y2","isTheSameXYCoordinates","isSnakeHeadOverlapApple","actualApplePosition","gameEnd","intensity","gameBuilder","getBlockedArea","blockedArea","Array","fill","forEach","_","push","initBlockedArea","isGameFinished","snakeHead","snakeTail","isGameOver","start","gameStart","end","isContinued","calculateNewPosition","newDirection","Down","Right","Up","Left","getInitialParameters","initDuckyPosition","initTailPosition","snakeBuilder","getUpdatesByStep","mutableDuckyPosition","mutableTailPosition","ducky","tail","addMagmacube","lastTailItemPosition","keyPressed","duckyPosition","tailPosition","direction","tailItemPosition","console","slice","None","cw","ccw","LeftArrow","indexOf","calculateDirection","newDuckyPosition","newTailPosition","microStep","updatesByStep","updatePosition","movingSize","currentPosition","subPosition","getPositions","head","stopStepTimer","mutableParameters","timerId","clearInterval","calculateUpdatesParameters","stepInterval","ceil","timerInterval","initialInterval","intervalDecreaseValue","stepIntervalDecreaseValue","updatesByStepCounter","stepperBuilder","stepperMutableParameters","stop","onTick","onComplete","window","setInterval","startStepTimer","increaseSpeed","decreasedInterval","keyToDirectionMap","ArrowLeft","ArrowRight","RightArrow","useKeys","keyPressedRef","useRef","keyResetRef","useEffect","onKeyPress","event","key","directionKey","isResetKey","isResetKeyPressed","document","addEventListener","removeEventListener","getPressedDirectionKey","map","isPressed","useGameLogic","useState","score","setScore","stopStepper","sceneTestTimer","stepper","game","makeStep","snakePositions","startGame","Info","className","extend","resources","Camera","cameraRef","orbitControlRef","setDefaultCamera","originCamera","camera","domElement","gl","up","enablePan","args","enableKeys","minZoom","maxZoom","minDistance","maxDistance","enableDamping","dampingFactor","screenSpacePanning","minPolarAngle","maxPolarAngle","createAnimationConfig","number","speed","timeOffset","type","offset","useModel","url","animation","model","useLoader","GLTFLoader","modelScene","clone","AnimationMixer","mixer","clockValueRef","clock","timeScale","modelAnimation","animations","clipAction","startAt","play","useFrame","clockValue","elapsedTime","getElapsedTime","timeDelta","update","Model","appleModelScene","dispose","object","scale","treesModelScene","duckyModelScene","cubeNumber","magmacubeModelScene","getRandomPositions","amount","worldSize","freeFieldSize","Boolean","Ground","loadedTexture","TextureLoader","wrapS","RepeatWrapping","wrapT","repeat","palmsPositions","useMemo","bigTreesPositions","bushesPositions","sideArraySize","randomBushesAmount","bushesOffset","getBushesPositions","renderObject","positions","Component","attach","color","Snake","SceneComponent","fallback","Scene","React","memo","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.9e7bbce6.chunk.js","sourcesContent":["export enum KeyPressedEnum {\n    LeftArrow, RightArrow, None,\n}\n\nexport enum DirectionKeyPressedEnum {\n    LeftArrow, RightArrow\n}\n","export enum MoveDirectionEnum {\n    Up = 0,\n    Right = 270,\n    Down = 180,\n    Left = 90,\n}\n","import { IPosition } from './types';\n\n\nconst HALF_FIELD_SIZE = 10;\nexport const FIELD_SIZE = HALF_FIELD_SIZE * 2;\nexport const PLANET_SIZE = 50 * FIELD_SIZE;\nexport const BLOCKED_ZONE_SIZE = 2 * FIELD_SIZE;\nexport const DUCK_START_POSITION: IPosition = {\n    x: HALF_FIELD_SIZE,\n    y: HALF_FIELD_SIZE,\n    angle: 180,\n};\n\nexport const MAX_MAGMACUBES = 100;\n\nexport const UPDATES_SETTINGS = {\n    startIntervalMs: 700,\n    intervalDecrease: 10,\n};\n\nexport const NAME = {\n    Ducky: 'ducky',\n    Apple: 'apple',\n    AmbientLight: 'ambientLight',\n    createMagmacubeName: (index: number): string => {\n        const magmacubePrefix = 'magmacube';\n\n        return `${magmacubePrefix}${index}`;\n    },\n};\n","import { Object3D, Scene } from 'three';\n\nimport { NAME } from '../constants';\nimport { IPosition } from '../types';\n\n\nexport const getObject3DByName = (scene: Scene, name: string): Object3D | never => {\n    const object3D = scene.children.find((value) => value.name === name);\n\n    if (object3D === undefined) {\n        throw new Error(`getObject3DByName. Can't find model with name=${name}, scene=${scene}`);\n    }\n\n    return object3D;\n};\n\nexport const getObject3DPositionByName = (scene: Scene, name: string): IPosition | never => {\n    const object3D = getObject3DByName(scene, name);\n\n    return {\n        x: object3D.position.x,\n        y: object3D.position.y,\n        angle: object3D.rotation.z,\n    };\n};\n\nexport const setObject3DPositionByName = (\n    scene: Scene,\n    name: string,\n    position: IPosition,\n    isUnderground: boolean,\n): void | never => {\n    const object3D = getObject3DByName(scene, name);\n\n    object3D.position.setX(position.x);\n    object3D.position.setY(position.y);\n    object3D.position.setZ(isUnderground ? -100 : 0);\n    object3D.rotation.set(0, 0, position.angle);\n};\n\nexport const isSceneReady = (scene: Scene): boolean => {\n    try {\n        getObject3DByName(scene, NAME.Ducky);\n        getObject3DByName(scene, NAME.Apple);\n\n        return true;\n    } catch (error) {\n        return false;\n    }\n};\n","import { Component } from './Component';\nimport * as utils from './utils';\n\n\nexport const SceneHelperComponent = Component;\nexport const sceneHelperUtil = utils;\n\n","import { forwardRef } from 'react';\nimport { useThree } from 'react-three-fiber';\nimport { Scene } from 'three';\n\n\nexport const Component = forwardRef<Scene>((\n    props,\n    ref,\n) => {\n    const { scene } = useThree();\n    if ((ref !== null) && (typeof ref !== 'function')) {\n        // eslint-disable-next-line no-param-reassign\n        ref.current = scene;\n    }\n\n    return null;\n});\n","export const degToRad = (deg: number): number => ((deg * Math.PI) / 180);\nexport const radToDeg = (rad: number): number => ((rad / Math.PI) * 180);\n\n","import { Scene } from 'three';\n\nimport { FIELD_SIZE } from '../constants';\nimport { sceneHelperUtil } from '../sceneHelper';\nimport { IPosition } from '../types';\nimport { degToRad, radToDeg } from '../utils';\n\n\ninterface ICoordinates {\n    x: number;\n    y: number;\n}\nconst HALF_FIELD_SIZE = FIELD_SIZE / 2;\n\ntype IConvertGlobal = {\n    (value: number): number;\n    (value: ICoordinates): ICoordinates;\n}\n\nexport const toGlobal: IConvertGlobal = (value: number | ICoordinates): any => {\n    if (typeof value === 'number') {\n        return value - HALF_FIELD_SIZE;\n    }\n\n    return {\n        x: value.x - HALF_FIELD_SIZE,\n        y: value.y - HALF_FIELD_SIZE,\n    };\n};\n\nexport const toLocal: IConvertGlobal = (value: number | ICoordinates): any => {\n    if (typeof value === 'number') {\n        return value + HALF_FIELD_SIZE;\n    }\n\n    return {\n        x: value.x + HALF_FIELD_SIZE,\n        y: value.y + HALF_FIELD_SIZE,\n    };\n};\n\nexport const isTheSameXYCoordinates = (\n    { x: x1, y: y1 }: IPosition,\n    { x: x2, y: y2 }: IPosition,\n): boolean => (x1 === x2) && (y1 === y2);\n\nexport const setPosition = (scene: Scene, name: string, position: IPosition, isUnderGround = false): void => {\n    const { x, y } = toGlobal({ x: position.x, y: position.y });\n    const angle = degToRad(position.angle);\n\n    sceneHelperUtil.setObject3DPositionByName(scene, name, { x, y, angle }, isUnderGround);\n};\n\nexport const getPosition = (scene: Scene, name: string): IPosition => {\n    const globalPosition = sceneHelperUtil.getObject3DPositionByName(scene, name);\n\n    const { x, y } = toLocal({ x: globalPosition.x, y: globalPosition.y });\n    const angle = radToDeg(globalPosition.angle);\n\n    return { x, y, angle };\n};\n\ntype PlainPosition = Pick<IPosition, 'x'| 'y'>\nexport const isPositionInBlocked = (\n    { x: testX, y: testY }: PlainPosition,\n    blockedPositions: PlainPosition[],\n): boolean => (\n    blockedPositions.filter(\n        ({ x: blockedX, y: blockedY }) => ((blockedX === testX) && (blockedY === testY)),\n    ).length > 0\n);\n","import { FIELD_SIZE } from '../../constants';\nimport { IPosition } from '../../types';\nimport { isPositionInBlocked } from '../utils';\n\n\nexport const calcRandomPositions = (blockedPositions: IPosition[]): IPosition => {\n    const getRandomCoordinates = () => ([\n        Math.floor(Math.random() * FIELD_SIZE),\n        Math.floor(Math.random() * FIELD_SIZE),\n    ]);\n\n    let [x, y] = getRandomCoordinates();\n    while (isPositionInBlocked({ x, y }, blockedPositions)) {\n        [x, y] = getRandomCoordinates();\n    }\n\n    return { x, y, angle: 0 };\n};\n","import { RefObject } from 'react';\nimport { Scene } from 'three';\n\nimport { DUCK_START_POSITION, NAME } from '../../constants';\nimport { IPosition } from '../../types';\nimport { isTheSameXYCoordinates, setPosition } from '../utils';\nimport { calcRandomPositions } from './utils';\n\n\nconst isSnakeHeadOverlapApple = (apple: IPosition, snake: IPosition[]): boolean => {\n    const snakeHeadPosition = snake[0];\n\n    return isTheSameXYCoordinates(apple, snakeHeadPosition);\n};\n\nexport const step = (\n    scene: Scene,\n    applePosition: IPosition,\n    snake: IPosition[],\n): { isSnakeEatApple: boolean, actualApplePosition: IPosition } => {\n    const isSnakeEatApple = isSnakeHeadOverlapApple(applePosition, snake);\n    let actualApplePosition = applePosition;\n    if (isSnakeEatApple) {\n        actualApplePosition = calcRandomPositions(snake);\n    }\n\n    setPosition(scene, NAME.Apple, actualApplePosition);\n\n    return {\n        isSnakeEatApple,\n        actualApplePosition,\n    };\n};\n\n\ntype IAppleBuilder = (sceneRef: RefObject<Scene | null>) => ({\n    reset: () => void;\n    step: (snakePosition: IPosition[]) => ({ isSnakeEatApple: boolean });\n});\n\nexport const appleBuilder: IAppleBuilder = (sceneRef) => {\n    let applePosition: IPosition = calcRandomPositions([DUCK_START_POSITION]);\n\n    return {\n        reset: () => {\n            applePosition = calcRandomPositions([DUCK_START_POSITION]);\n        },\n        step: (snakePosition) => {\n            const scene = sceneRef.current;\n            if (!scene) {\n                return { isSnakeEatApple: false };\n            }\n            const { isSnakeEatApple, actualApplePosition } = step(scene, applePosition, snakePosition);\n\n            applePosition = actualApplePosition;\n            return { isSnakeEatApple };\n        },\n    };\n};\n","import { RefObject } from 'react';\nimport { AmbientLight, Scene } from 'three';\n\nimport { BLOCKED_ZONE_SIZE, NAME } from '../../constants';\nimport { sceneHelperUtil } from '../../sceneHelper';\nimport { isPositionInBlocked } from '../utils';\nimport { IPlainPosition } from './types';\n\n\nconst initBlockedArea = (): () => IPlainPosition[] => {\n    const blockedArea: IPlainPosition[] = [];\n\n    new Array(BLOCKED_ZONE_SIZE).fill(0).forEach((_, index) => {\n        blockedArea.push({ x: -BLOCKED_ZONE_SIZE / 2 + index, y: BLOCKED_ZONE_SIZE / 2 });\n        blockedArea.push({ x: -BLOCKED_ZONE_SIZE / 2 + index, y: -BLOCKED_ZONE_SIZE / 2 });\n        blockedArea.push({ x: BLOCKED_ZONE_SIZE / 2, y: -BLOCKED_ZONE_SIZE / 2 + index });\n        blockedArea.push({ x: -BLOCKED_ZONE_SIZE / 2, y: -BLOCKED_ZONE_SIZE / 2 + index });\n    });\n\n    return () => blockedArea;\n};\n\nconst isGameOver = (snakeHead: IPlainPosition, snakeTail: IPlainPosition[], blockedArea: IPlainPosition[]) => (\n    isPositionInBlocked(snakeHead, snakeTail) || isPositionInBlocked(snakeHead, blockedArea)\n);\n\nconst gameEnd = (scene: Scene): void => {\n    const ambientLight = sceneHelperUtil.getObject3DByName(scene, NAME.AmbientLight) as AmbientLight;\n    ambientLight.intensity = 0;\n};\n\nconst gameStart = (scene: Scene): void => {\n    const ambientLight = sceneHelperUtil.getObject3DByName(scene, NAME.AmbientLight) as AmbientLight;\n    ambientLight.intensity = 1;\n};\n\ntype IGameBuilder = (scene: RefObject<Scene | null>) => {\n    step: (snakeHead: IPlainPosition, snakeTail:IPlainPosition []) => void,\n    end: () => void;\n    start: () => void;\n    isContinued: () => boolean;\n}\n\nexport const gameBuilder: IGameBuilder = (sceneRef) => {\n    const getBlockedArea = initBlockedArea();\n    let isGameFinished = false;\n\n    return {\n        step: (snakeHead, snakeTail) => {\n            const scene = sceneRef.current;\n            if (!scene) {\n                return;\n            }\n            isGameFinished = isGameOver(snakeHead, snakeTail, getBlockedArea());\n            if (isGameFinished) {\n                gameEnd(scene);\n            }\n        },\n        start: () => {\n            const scene = sceneRef.current;\n            if (!scene) {\n                return;\n            }\n            isGameFinished = false;\n            gameStart(scene);\n        },\n        end: () => {\n            const scene = sceneRef.current;\n            if (!scene) {\n                return;\n            }\n            isGameFinished = true;\n            gameEnd(scene);\n        },\n        isContinued: () => !isGameFinished,\n    };\n};\n","import { IPosition } from '../../types';\nimport { KeyPressedEnum } from '../useKeys/types';\nimport { MoveDirectionEnum } from './types';\n\n\nexport const calculateNewPosition = (position: IPosition, newDirection: MoveDirectionEnum, step = 1): IPosition => {\n    switch (newDirection) {\n        case MoveDirectionEnum.Down:\n            return {\n                x: position.x,\n                y: position.y - step,\n                angle: MoveDirectionEnum.Down,\n            };\n        case MoveDirectionEnum.Right:\n            return {\n                x: position.x + step,\n                y: position.y,\n                angle: MoveDirectionEnum.Right,\n            };\n        case MoveDirectionEnum.Up:\n            return {\n                x: position.x,\n                y: position.y + step,\n                angle: MoveDirectionEnum.Up,\n            };\n        case MoveDirectionEnum.Left:\n            return {\n                x: position.x - step,\n                y: position.y,\n                angle: MoveDirectionEnum.Left,\n            };\n        default:\n            throw new Error(`calculateNewPosition. Unknown newDirection type = ${newDirection}`);\n    }\n};\n\nexport const calculateDirection = (keyPressed: KeyPressedEnum, direction: MoveDirectionEnum): MoveDirectionEnum => {\n    if (keyPressed === KeyPressedEnum.None) {\n        return direction;\n    }\n\n    const cw = [MoveDirectionEnum.Up, MoveDirectionEnum.Right, MoveDirectionEnum.Down, MoveDirectionEnum.Left];\n    const ccw = [MoveDirectionEnum.Up, MoveDirectionEnum.Left, MoveDirectionEnum.Down, MoveDirectionEnum.Right];\n\n    const rotation = keyPressed === KeyPressedEnum.LeftArrow ? ccw : cw;\n    const index = rotation.indexOf(direction);\n    const newIndex = (index + 1) % rotation.length;\n\n    return rotation[newIndex];\n};\n","import { RefObject } from 'react';\nimport { Scene } from 'three';\n\nimport { DUCK_START_POSITION, NAME } from '../../constants';\nimport { IPosition } from '../../types';\nimport { KeyPressedEnum } from '../useKeys/types';\nimport { getPosition, setPosition } from '../utils';\nimport { MoveDirectionEnum } from './types';\nimport { calculateDirection, calculateNewPosition } from './utils';\n\n\nconst step = (\n    scene: Scene,\n    duckyPosition: IPosition,\n    tailPosition: IPosition[],\n    direction: MoveDirectionEnum,\n) => {\n    try {\n        setPosition(scene, NAME.Ducky, duckyPosition);\n        tailPosition.forEach((tailItemPosition, index) => {\n            setPosition(scene, NAME.createMagmacubeName(index), tailItemPosition);\n        });\n    } catch (error) {\n        // eslint-disable-next-line no-console\n        console.error(error);\n    }\n\n    const newDuckyPosition = calculateNewPosition(duckyPosition, direction);\n    const newTailPosition = tailPosition.length\n        ? [{ ...duckyPosition }, ...tailPosition.slice(0, -1)]\n        : [];\n\n    return [newDuckyPosition, newTailPosition] as const;\n};\n\nconst microStep = (\n    scene: Scene,\n    duckyPosition: IPosition,\n    tailPosition: IPosition[],\n    getUpdatesByStep: () => number,\n) => {\n    const updatesByStep = getUpdatesByStep();\n    const updatePosition = (name: string, angle: IPosition['angle'], movingSize: number) => {\n        try {\n            const currentPosition = getPosition(scene, name);\n            const subPosition = calculateNewPosition(currentPosition, angle, movingSize);\n            setPosition(scene, name, subPosition);\n        } catch (error) {\n            // eslint-disable-next-line no-console\n            console.error(error);\n        }\n    };\n\n    updatePosition(NAME.Ducky, duckyPosition.angle, 1 / updatesByStep);\n    tailPosition.forEach(({ angle }, index) => (\n        updatePosition(NAME.createMagmacubeName(index), angle, 1 / updatesByStep)\n    ));\n};\n\nconst getInitialParameters = (): { initDuckyPosition: IPosition, initTailPosition: IPosition[]} => ({\n    initDuckyPosition: { ...DUCK_START_POSITION },\n    initTailPosition: [],\n});\n\ntype ISnakeBuilder = (sceneRef: RefObject<Scene | null>, getUpdatesByStep: () => number) => ({\n    reset: () => void;\n    addMagmacube: () => void;\n    step: (direction: KeyPressedEnum) => void;\n    microStep: () => void;\n    getPositions: () => { head: IPosition; tail: IPosition[] };\n});\n\nexport const snakeBuilder: ISnakeBuilder = (sceneRef, getUpdatesByStep) => {\n    const { initDuckyPosition, initTailPosition } = getInitialParameters();\n\n    let mutableDuckyPosition: IPosition = initDuckyPosition;\n    let mutableTailPosition: IPosition[] = initTailPosition;\n\n    return {\n        reset: () => {\n            const scene = sceneRef.current;\n            if (!scene) {\n                return;\n            }\n            mutableTailPosition.forEach((_, index) => {\n                setPosition(\n                    scene,\n                    NAME.createMagmacubeName(index),\n                    { x: 0, y: 0, angle: 0 },\n                    true,\n                );\n            });\n            const { initDuckyPosition: ducky, initTailPosition: tail } = getInitialParameters();\n\n            mutableDuckyPosition = ducky;\n            mutableTailPosition = tail;\n        },\n        addMagmacube: () => {\n            const lastTailItemPosition = { ...mutableTailPosition[mutableTailPosition.length - 1] };\n            mutableTailPosition.push({ ...lastTailItemPosition });\n        },\n        step: (keyPressed) => {\n            const scene = sceneRef.current;\n            if (!scene) {\n                return;\n            }\n            const [newDuckyPosition, newTailPosition] = step(\n                scene,\n                mutableDuckyPosition,\n                mutableTailPosition,\n                calculateDirection(keyPressed, mutableDuckyPosition.angle),\n            );\n\n            mutableDuckyPosition = newDuckyPosition;\n            mutableTailPosition = newTailPosition;\n        },\n        microStep: () => {\n            const scene = sceneRef.current;\n            if (!scene) {\n                return;\n            }\n            microStep(scene, mutableDuckyPosition, mutableTailPosition, getUpdatesByStep);\n        },\n        getPositions: () => ({\n            head: mutableDuckyPosition,\n            tail: mutableTailPosition,\n        }),\n    };\n};\n","import { MIN_STEP_INTERVAL_MS, MIN_UPDATES_BY_STEP, UPDATES_BY_STEP_RATIO } from './constants';\nimport { IStepperParameters } from './types';\n\n\n/* eslint-disable no-param-reassign */\n\nconst stopStepTimer = (mutableParameters: IStepperParameters): void => {\n    mutableParameters.timerId && clearInterval(mutableParameters.timerId);\n};\n\nconst startStepTimer = (\n    mutableParameters: IStepperParameters,\n    onTick: () => void,\n    onComplete: () => void,\n): void => {\n    mutableParameters.updatesByStepCounter = mutableParameters.updatesByStep - 1;\n    mutableParameters.timerId = window.setInterval(() => {\n        onTick();\n        if (mutableParameters.updatesByStepCounter === 0) {\n            stopStepTimer(mutableParameters);\n            onComplete();\n            return;\n        }\n        mutableParameters.updatesByStepCounter -= 1;\n    }, mutableParameters.timerInterval);\n};\n\nconst calculateUpdatesParameters = (\n    stepInterval: number,\n): Pick<IStepperParameters, 'updatesByStep' | 'timerInterval'> => {\n    const updatesByStep = Math.ceil(stepInterval / UPDATES_BY_STEP_RATIO) || MIN_UPDATES_BY_STEP;\n\n    return {\n        updatesByStep,\n        timerInterval: Math.floor(stepInterval / updatesByStep),\n    };\n};\n\nconst increaseSpeed = (\n    stepperMutableParameters: IStepperParameters,\n): void => {\n    const { stepInterval, stepIntervalDecreaseValue } = stepperMutableParameters;\n    const decreasedInterval = ((stepInterval - stepIntervalDecreaseValue) < MIN_STEP_INTERVAL_MS)\n        ? MIN_STEP_INTERVAL_MS\n        : stepInterval - stepIntervalDecreaseValue;\n    const { updatesByStep, timerInterval } = calculateUpdatesParameters(decreasedInterval);\n\n    stepperMutableParameters.stepInterval = decreasedInterval;\n    stepperMutableParameters.updatesByStep = updatesByStep;\n    stepperMutableParameters.timerInterval = timerInterval;\n};\n\nconst getInitialParameters = (initialInterval: number, intervalDecreaseValue: number): IStepperParameters => ({\n    stepInterval: initialInterval,\n    stepIntervalDecreaseValue: intervalDecreaseValue,\n    timerId: null,\n    updatesByStepCounter: 0,\n    ...calculateUpdatesParameters(initialInterval),\n});\n\ntype IStepperBuilder = (initialInterval: number, intervalDecreaseValue: number) => ({\n    reset: () => void;\n    stop: () => void;\n    step: (onTick: () => void, onComplete: () => void) => void;\n    increaseSpeed: () => void;\n    getUpdatesByStep: () => number;\n});\n\nexport const stepperBuilder: IStepperBuilder = (initialInterval: number, intervalDecreaseValue: number) => {\n    let stepperMutableParameters: IStepperParameters = getInitialParameters(initialInterval, intervalDecreaseValue);\n\n    return {\n        reset: () => {\n            stopStepTimer(stepperMutableParameters);\n            stepperMutableParameters = getInitialParameters(initialInterval, intervalDecreaseValue);\n        },\n        stop: () => {\n            stopStepTimer(stepperMutableParameters);\n        },\n        step: (onTick, onComplete) => {\n            startStepTimer(stepperMutableParameters, onTick, onComplete);\n        },\n        increaseSpeed: () => {\n            increaseSpeed(stepperMutableParameters);\n        },\n        getUpdatesByStep: () => stepperMutableParameters.updatesByStep,\n    };\n};\n","export const UPDATES_BY_STEP_RATIO = 50;\nexport const MIN_UPDATES_BY_STEP = 1;\nexport const MIN_STEP_INTERVAL_MS = 50;\n","import { DirectionKeyPressedEnum } from './types';\n\n\nconst keyToDirectionMap = {\n    ArrowLeft: DirectionKeyPressedEnum.LeftArrow,\n    ArrowRight: DirectionKeyPressedEnum.RightArrow,\n};\n\nexport const getDirectionKeyPressed = (key: string): DirectionKeyPressedEnum | undefined => (\n    keyToDirectionMap[key as keyof typeof keyToDirectionMap]\n);\n\nexport const isResetKeyPressed = (key: string): boolean => (key === 'R' || key === 'r');\n","import { useEffect, useRef } from 'react';\n\nimport { DirectionKeyPressedEnum, KeyPressedEnum } from './types';\nimport { getDirectionKeyPressed, isResetKeyPressed } from './utils';\n\n\ntype IUseKeys = () => {\n    getPressedDirectionKey: () => KeyPressedEnum;\n    isResetKeyPressed: () => boolean;\n}\nexport const useKeys: IUseKeys = () => {\n    const keyPressedRef = useRef<DirectionKeyPressedEnum | undefined>(undefined);\n    const keyResetRef = useRef<boolean>(false);\n\n    useEffect(() => {\n        const onKeyPress = (event: KeyboardEvent) => {\n            const directionKey = getDirectionKeyPressed(event.key);\n            const isResetKey = isResetKeyPressed(event.key);\n\n            if (directionKey !== undefined) {\n                keyPressedRef.current = directionKey;\n            }\n\n            if (isResetKey) {\n                keyResetRef.current = true;\n            }\n        };\n\n        document.addEventListener('keydown', onKeyPress);\n\n        return () => document.removeEventListener('keydown', onKeyPress);\n    }, []);\n\n    return {\n        getPressedDirectionKey: () => {\n            const key = keyPressedRef.current;\n            keyPressedRef.current = undefined;\n\n            const map = {\n                [DirectionKeyPressedEnum.LeftArrow]: KeyPressedEnum.LeftArrow,\n                [DirectionKeyPressedEnum.RightArrow]: KeyPressedEnum.RightArrow,\n            };\n\n            return key === undefined ? KeyPressedEnum.None : map[key];\n        },\n        isResetKeyPressed: () => {\n            const isPressed = keyResetRef.current;\n            keyResetRef.current = false;\n\n            return isPressed;\n        },\n    };\n};\n","import { RefObject, useEffect, useState } from 'react';\nimport { Scene } from 'three';\n\nimport { UPDATES_SETTINGS } from '../constants';\nimport { sceneHelperUtil } from '../sceneHelper';\nimport { appleBuilder } from './apple';\nimport { gameBuilder } from './game';\nimport { snakeBuilder } from './snake';\nimport { stepperBuilder } from './stepper';\nimport { useKeys } from './useKeys';\n\n\nexport const useGameLogic = (sceneRef: RefObject<Scene | null>): { score: number } => {\n    const { getPressedDirectionKey, isResetKeyPressed } = useKeys();\n    const [score, setScore] = useState(0);\n\n    useEffect(() => {\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        let stopStepper: () => void = () => {};\n\n        const startGame = (): () => void => {\n            const stepper = stepperBuilder(UPDATES_SETTINGS.startIntervalMs, UPDATES_SETTINGS.intervalDecrease);\n            const snake = snakeBuilder(sceneRef, stepper.getUpdatesByStep);\n            const apple = appleBuilder(sceneRef);\n            const game = gameBuilder(sceneRef);\n\n            const makeStep = () => {\n                stepper.step(\n                    () => game.isContinued() && snake.microStep(),\n                    () => {\n                        const snakePositions = snake.getPositions();\n                        game.step(snakePositions.head, snakePositions.tail);\n                        if (game.isContinued()) {\n                            const { isSnakeEatApple } = apple.step([snakePositions.head, ...snakePositions.tail]);\n                            if (isSnakeEatApple) {\n                                setScore((value) => (value + 1));\n                                stepper.increaseSpeed();\n                                snake.addMagmacube();\n                            }\n                            snake.step(getPressedDirectionKey());\n                        }\n                        if (isResetKeyPressed()) {\n                            setScore(0);\n                            stepper.reset();\n                            snake.reset();\n                            apple.reset();\n                            game.start();\n                        }\n                        makeStep();\n                    },\n                );\n            };\n\n            snake.step(getPressedDirectionKey());\n            makeStep();\n            return stepper.stop;\n        };\n\n        const sceneTestTimer = setInterval(() => {\n            if (sceneRef.current && sceneHelperUtil.isSceneReady(sceneRef.current)) {\n                clearInterval(sceneTestTimer);\n\n                stopStepper = startGame();\n            }\n        }, 100);\n\n        return stopStepper;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n\n    return { score };\n};\n","import React from 'react';\n\n\ninterface IProps {\n    score: number;\n}\n\nexport const Info: React.FC<IProps> = ({ score }) => (\n    <div className=\"info-wrapper\">\n        <p className=\"info-score\">{`Score: ${score}`}</p>\n        <p>&apos;←&apos; - turn left</p>\n        <p>&apos;→&apos; - turn right</p>\n        <p>&apos;r&apos; - restart game</p>\n    </div>\n);\n","import React, { useEffect, useRef } from 'react';\nimport { extend, useThree } from 'react-three-fiber';\n\nimport { FIELD_SIZE } from '../constants';\nimport * as resources from '../resources';\nimport { degToRad } from '../utils';\n\n\nextend(resources);\n\nexport const Camera: React.FC = () => {\n    const cameraRef = useRef();\n    const orbitControlRef = useRef();\n    const {\n        scene,\n        setDefaultCamera,\n        camera: originCamera,\n        gl: { domElement },\n    } = useThree();\n\n    useEffect(() => {\n        const camera = cameraRef?.current;\n        if (!camera) {\n            return;\n        }\n\n        setDefaultCamera(camera);\n    }, [setDefaultCamera, scene]);\n\n    return (\n        <group>\n            <perspectiveCamera\n                ref={cameraRef}\n                position={[FIELD_SIZE, FIELD_SIZE, FIELD_SIZE]}\n                up={[0, 0, 1]}\n            />\n            <orbitControls\n                enablePan={false}\n                ref={orbitControlRef}\n                args={[originCamera, domElement]}\n                enableKeys={false}\n                minZoom={1}\n                maxZoom={1}\n                minDistance={1.3 * FIELD_SIZE}\n                maxDistance={3 * FIELD_SIZE}\n                enableDamping\n                dampingFactor={0.05}\n                screenSpacePanning={false}\n                minPolarAngle={degToRad(0)}\n                maxPolarAngle={degToRad(75)}\n            />\n        </group>\n    );\n};\n","import { IAnimation, IWithAnimation, IWithoutAnimation } from './types';\n\n\nexport const isWithoutAnimation = (value: IAnimation): value is IWithoutAnimation => (\n    value.type === 'undefined'\n);\n\nexport const createAnimationConfig = (number: number, speed: number, timeOffset?: number): IWithAnimation => ({\n    type: 'defined',\n    number,\n    speed,\n    offset: timeOffset ?? 0,\n});\n\nexport const createEmptyAnimationConfig = (): IWithoutAnimation => ({\n    type: 'undefined',\n});\n","import { useEffect, useRef, useState } from 'react';\nimport { useFrame, useLoader, useThree } from 'react-three-fiber';\nimport { AnimationMixer } from 'three';\nimport { GLTF, GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\n\nimport { IAnimation } from './types';\nimport { isWithoutAnimation } from './utils';\n\n\nexport const useModel = (url: string, animation: IAnimation): GLTF['scene'] => {\n    const model = useLoader(GLTFLoader, url);\n    const modelScene = model.scene.clone();\n    const [mixer] = useState(() => new AnimationMixer(modelScene));\n    const clockValueRef = useRef<number | null>(null);\n    const { clock } = useThree();\n\n    useEffect(() => {\n        if (isWithoutAnimation(animation)) {\n            return;\n        }\n\n        mixer.timeScale = animation.speed;\n        const modelAnimation = model.animations[animation.number];\n        modelAnimation && mixer.clipAction(modelAnimation).startAt(animation.offset).play();\n    }, [model, mixer, animation]);\n\n    useFrame(() => {\n        const clockValue = clockValueRef.current;\n        const elapsedTime = clock.getElapsedTime();\n        const timeDelta = elapsedTime - (clockValue ?? 0);\n        clockValueRef.current = elapsedTime;\n        mixer.update(timeDelta);\n        clock.getElapsedTime();\n    });\n\n    return modelScene;\n};\n","import { Apple } from './Apple';\nimport { BigTree } from './BigTree';\nimport { Bush } from './Bush';\nimport { Ducky } from './Ducky';\nimport { Magmacube } from './Magmacube';\nimport { PalmTree } from './PalmTree';\n\n\nexport const Model = {\n    Apple,\n    BigTree,\n    Bush,\n    Ducky,\n    Magmacube,\n    PalmTree,\n};\n","import React from 'react';\n\nimport { NAME } from '../constants';\nimport { degToRad } from '../utils';\nimport { useModel } from './useModel';\nimport { createEmptyAnimationConfig } from './utils';\n\n\nexport const Apple: React.FC = () => {\n    const appleModelScene = useModel(\n        '/models/apple/scene.gltf',\n        createEmptyAnimationConfig(),\n    );\n\n    return (\n        <group\n            name={NAME.Apple}\n            position={[0, 0, -100]}\n            dispose={null}\n        >\n            <mesh>\n                <primitive\n                    object={appleModelScene}\n                    rotation={[degToRad(90), 0, 0]}\n                    position={[0, -0.2, 0.8]}\n                    scale={[0.00015, 0.00015, 0.00015]}\n                />\n            </mesh>\n        </group>\n    );\n};\n","import React from 'react';\n\nimport { degToRad } from '../utils';\nimport { IModel } from './types';\nimport { useModel } from './useModel';\nimport { createEmptyAnimationConfig } from './utils';\n\n\nexport const BigTree: React.FC<IModel> = ({ position, angle }) => {\n    const treesModelScene = useModel(\n        'models/bigTree/scene.gltf',\n        createEmptyAnimationConfig(),\n    );\n\n    return (\n        <group\n            position={[...position, 0]}\n            dispose={null}\n            rotation={[0, 0, angle]}\n        >\n            <mesh>\n                <primitive\n                    object={treesModelScene}\n                    rotation={[degToRad(90), 0, 0]}\n                    position={[0, 0, 0.8]}\n                    scale={[40, 40, 40]}\n                />\n            </mesh>\n        </group>\n    );\n};\n","import React from 'react';\n\nimport { degToRad } from '../utils';\nimport { IModel } from './types';\nimport { useModel } from './useModel';\nimport { createEmptyAnimationConfig } from './utils';\n\n\nexport const Bush: React.FC<IModel> = ({ position, angle }) => {\n    const treesModelScene = useModel(\n        '/models/bush/scene.gltf',\n        createEmptyAnimationConfig(),\n    );\n\n    return (\n        <group\n            position={[...position, 0]}\n            rotation={[0, 0, angle]}\n            dispose={null}\n        >\n            <mesh>\n                <primitive\n                    object={treesModelScene}\n                    rotation={[degToRad(90), 0, 0]}\n                    position={[0, 0, 0.2]}\n                    scale={[0.04, 0.04, 0.04]}\n                />\n            </mesh>\n        </group>\n    );\n};\n","import React from 'react';\n\nimport { degToRad } from '../utils';\nimport { IModel } from './types';\nimport { useModel } from './useModel';\nimport { createAnimationConfig } from './utils';\n\n\nexport const Ducky: React.FC<IModel> = ({ position, angle, name }) => {\n    const duckyModelScene = useModel(\n        '/models/ducky/scene.gltf',\n        createAnimationConfig(0, 4),\n    );\n\n    return (\n        <group\n            name={name}\n            position={[...position, 0]}\n            dispose={null}\n            rotation={[0, 0, angle]}\n        >\n            <mesh>\n                <primitive\n                    object={duckyModelScene}\n                    rotation={[degToRad(90), 0, 0]}\n                    position={[0, 0, 0.5]}\n                    scale={[0.08, 0.08, 0.08]}\n                />\n            </mesh>\n        </group>\n    );\n};\n","import React from 'react';\n\nimport { degToRad } from '../utils';\nimport { useModel } from './useModel';\nimport { createAnimationConfig } from './utils';\n\n\ninterface IProps {\n    name: string;\n\n    cubeNumber?: number;\n}\n\nconst CUBE_ANIMATION_BASE_TIME_S = 0.1;\nexport const Magmacube: React.FC<IProps> = ({ cubeNumber = 0, name }) => {\n    const magmacubeModelScene = useModel(\n        '/models/magmacube/scene.gltf',\n        createAnimationConfig(0, 1, cubeNumber * CUBE_ANIMATION_BASE_TIME_S),\n    );\n\n    return (\n        <group\n            name={name}\n            position={[0, 0, -100]}\n        >\n            <primitive\n                object={magmacubeModelScene}\n                rotation={[degToRad(90), degToRad(180), 0]}\n                position={[0, 0, 0.9]}\n                scale={[0.1, 0.1, 0.1]}\n            />\n        </group>\n    );\n};\n","import React from 'react';\n\nimport { degToRad } from '../utils';\nimport { IModel } from './types';\nimport { useModel } from './useModel';\nimport { createEmptyAnimationConfig } from './utils';\n\n\nexport const PalmTree: React.FC<IModel> = ({ position, angle }) => {\n    const treesModelScene = useModel(\n        '/models/palmTree/scene.gltf',\n        createEmptyAnimationConfig(),\n    );\n\n    return (\n        <group\n            position={[...position, 0]}\n            dispose={null}\n            rotation={[0, 0, angle]}\n        >\n            <mesh>\n                <primitive\n                    object={treesModelScene}\n                    rotation={[degToRad(90), 0, 0]}\n                    position={[0, 0, 0.8]}\n                    scale={[80, 80, 80]}\n                />\n            </mesh>\n        </group>\n    );\n};\n","import { IPosition } from '../types';\n\n\nexport const getRandomPositions = (\n    amount: number,\n    worldSize: number,\n    freeFieldSize: number,\n): IPosition[] => (\n    new Array(amount).fill(0).map(() => {\n        const getRandomCoordinates = () => ([\n            Math.floor((Math.random() - 0.5) * worldSize),\n            Math.floor((Math.random() - 0.5) * worldSize),\n        ]);\n\n        const isInFreeField = (testX: number, testY: number): boolean => (\n            (testX >= -freeFieldSize) && (testX <= freeFieldSize)\n            && (testY >= -freeFieldSize) && (testY <= freeFieldSize)\n        );\n\n        const [x, y] = getRandomCoordinates();\n\n        return (isInFreeField(x, y)\n            ? null\n            : {\n                x,\n                y,\n                angle: Math.floor(Math.random() * 4) * (Math.PI / 2),\n            }\n        );\n    }).filter((value): value is IPosition => Boolean(value))\n);\n\nconst DIVIDER = 8;\nexport const getBushesPositions = (amount: number, worldSize: number, freeFieldSize: number): IPosition[] => {\n    const sideArraySize = Math.floor((2 * freeFieldSize) / DIVIDER);\n    const randomBushesAmount = amount > sideArraySize * 4\n        ? amount - sideArraySize * 4\n        : 0;\n    const bushesOffset = freeFieldSize / 2 + 5;\n    return [\n        ...new Array(sideArraySize).fill(0).map((_, index) => ({\n            x: -bushesOffset + index * DIVIDER,\n            y: -bushesOffset,\n            angle: Math.random() * Math.PI * 2,\n        })),\n        ...new Array(sideArraySize).fill(0).map((_, index) => ({\n            x: -bushesOffset + index * DIVIDER,\n            y: bushesOffset,\n            angle: Math.random() * Math.PI * 2,\n        })),\n        ...new Array(sideArraySize).fill(0).map((_, index) => ({\n            x: bushesOffset,\n            y: -bushesOffset + index * DIVIDER,\n            angle: Math.random() * Math.PI * 2,\n        })),\n        ...new Array(sideArraySize).fill(0).map((_, index) => ({\n            x: -bushesOffset,\n            y: -bushesOffset + index * DIVIDER,\n            angle: Math.random() * Math.PI * 2,\n        })),\n        ...getRandomPositions(randomBushesAmount, worldSize, bushesOffset + 1),\n    ];\n};\n","import React, { useEffect, useMemo } from 'react';\nimport { useLoader } from 'react-three-fiber';\nimport { RepeatWrapping, TextureLoader } from 'three';\n\nimport { FIELD_SIZE, PLANET_SIZE } from '../constants';\nimport { Model } from '../model';\nimport { getBushesPositions, getRandomPositions } from './utils';\n\n\nconst PALMS_AMOUNT = 60;\nconst BIG_TREES_AMOUNT = 60;\nconst BUSHES_AMOUNT = 1000;\n\nexport const Ground: React.FC = () => {\n    const loadedTexture = useLoader(TextureLoader, '/textures/grass.jpg');\n    useEffect(() => {\n        loadedTexture.wrapS = RepeatWrapping;\n        loadedTexture.wrapT = RepeatWrapping;\n        loadedTexture.repeat.set(PLANET_SIZE, PLANET_SIZE);\n    }, [loadedTexture]);\n\n    const palmsPositions = useMemo(() => getRandomPositions(PALMS_AMOUNT, PLANET_SIZE, FIELD_SIZE), []);\n    const bigTreesPositions = useMemo(() => getRandomPositions(BIG_TREES_AMOUNT, PLANET_SIZE, FIELD_SIZE), []);\n    const bushesPositions = useMemo(() => getBushesPositions(BUSHES_AMOUNT, PLANET_SIZE, FIELD_SIZE), []);\n\n    const renderObject = (positions: ReturnType<typeof getRandomPositions>, Component: React.ElementType) => (\n        <>\n            {positions.map(({ x, y, angle }) => (\n                <Component key={`${x}${y}${angle}`} position={[x, y]} angle={angle} />\n            ))}\n        </>\n    );\n\n    return (\n        <>\n            <fog attach=\"fog\" args={['black', FIELD_SIZE, PLANET_SIZE * 0.08]} />\n            <mesh>\n                <boxBufferGeometry\n                    attach=\"geometry\"\n                    args={[PLANET_SIZE, PLANET_SIZE, 1]}\n                />\n                <meshStandardMaterial attach=\"material\" color=\"green\" map={loadedTexture} />\n                {renderObject(palmsPositions, Model.PalmTree)}\n                {renderObject(bigTreesPositions, Model.BigTree)}\n                {renderObject(bushesPositions, Model.Bush)}\n            </mesh>\n        </>\n    );\n};\n","import React from 'react';\n\nimport { MAX_MAGMACUBES, NAME } from './constants';\nimport { Model } from './model';\n\n\nexport const Snake: React.FC = () => (\n    <>\n        <Model.Ducky\n            name={NAME.Ducky}\n            position={[0, 0]}\n            angle={0}\n        />\n        {new Array(MAX_MAGMACUBES).fill(0).map((_, index) => (\n            <Model.Magmacube\n                /* eslint-disable-next-line react/no-array-index-key */\n                key={NAME.createMagmacubeName(index)}\n                name={NAME.createMagmacubeName(index)}\n                cubeNumber={index}\n            />\n        ))}\n    </>\n);\n","import React, { forwardRef, Suspense } from 'react';\nimport { Canvas } from 'react-three-fiber';\nimport { Sky } from 'drei';\nimport { Scene as SceneType } from 'three';\n\nimport { Camera } from './camera';\nimport { NAME } from './constants';\nimport { Ground } from './Ground';\nimport { Model } from './model';\nimport { SceneHelperComponent } from './sceneHelper';\nimport { Snake } from './Snake';\n\n\nconst SceneComponent = forwardRef<SceneType>((props, sceneRef) => (\n    <Canvas color=\"red\">\n        <Camera />\n        <ambientLight name={NAME.AmbientLight} intensity={1} />\n        <Sky />\n        <Suspense fallback={null}>\n            <Ground />\n            <Snake />\n            <Model.Apple />\n            <SceneHelperComponent ref={sceneRef} />\n        </Suspense>\n    </Canvas>\n));\n\nexport const Scene = React.memo(SceneComponent);\n","import React, { useRef } from 'react';\nimport { Scene as SceneType } from 'three';\n\nimport { useGameLogic } from './gameLogic';\nimport { Info } from './Info';\nimport { Scene } from './Scene';\n\n\nexport const App: React.FC = () => {\n    const sceneRef = useRef<SceneType>(null);\n    const { score } = useGameLogic(sceneRef);\n\n    return (\n        <>\n            <Info score={score} />\n            <Scene ref={sceneRef} />\n        </>\n    );\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport { App } from './App';\nimport './index.css';\n\n\nReactDOM.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>,\n    document.getElementById('root'),\n);\n"],"sourceRoot":""}